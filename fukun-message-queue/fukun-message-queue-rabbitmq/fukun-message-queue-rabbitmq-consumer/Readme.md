# 实现mq到消费端的消息可靠性投递

## Rabbitmq 重消费处理

### 死信队列介绍    
死信队列&死信交换器：DLX，dead-letter-exchange,称之为死信交换器，
当消息变成一个死信之后，如果这个消息所在的队列存在x-dead-letter-exchange参数，
那么它会被发送到x-dead-letter-exchange对应值的交换器上，这个交换器就称之为死信交换器，
与这个死信交换器绑定的队列就是死信队列。
 
利用DLX，当消息在一个队列中变成死信 (dead message) 之后，
它能被重新publish到另一个Exchange，这个Exchange就是DLX。  
    
消息变成死信（死信消息）有以下几种情况  
消息被拒绝(basic.reject / basic.nack)，并且不再重新投递requeue = false  
消息TTL过期  
队列达到最大长度，队列超载  

变成了“死信”后，被重新投递（publish）到另一个Exchange，该Exchange就是DLX
然后该Exchange根据绑定规则转发到对应的队列上，监听该队列就可以重新消费，
说白了就是没有被消费的消息换个地方重新被消费。  

生产者   -->  消息 --> 交换机  --> 队列  --> 变成死信  --> DLX交换机 -->队列 --> 消费者    


过期消息    
在 rabbitmq 中存在2种方可设置消息的过期时间，第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间，
第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。如果同时使用这2种方法，那么以过期时间小的那个数值为准。
当消息达到过期时间还没有被消费，那么那个消息就成为了一个死信消息。  
队列设置：在队列申明的时候使用 x-message-ttl 参数，单位为 毫秒  
单个消息设置：是设置消息属性的 expiration 参数的值，单位为 毫秒  

延时队列
在rabbitmq中不存在延时队列，但是我们可以通过设置消息的过期时间和死信队列来模拟出延时队列。
消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。

死信处理过程  
DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。    
当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。   
可以监听这个队列中的消息做相应的处理。  

### 业务需求  
需求：用户在系统中发送一个消息（比如创建订单的消息），如果10s后，消费者没有消费（用户没有进行支付），
那么消息就会进入到死信队列中（自动取消订单）。    
分析：
        1、上面这个情况，我们就适合使用延时队列来实现，那么延时队列如何创建    
        2、延时队列可以由 过期消息+死信队列 来实现     
        3、过期消息通过队列中设置 x-message-ttl 参数实现或者单个消息设置expiration属性。    
        4、死信队列通过在队列申明时，给队列设置 x-dead-letter-exchange 参数，然后另外申明一个队列绑定x-dead-letter-exchange对应的交换器。    
        
    
        
        





    
  

